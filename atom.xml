<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JOHN&#39;S BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-24T08:35:44.821Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Johnny Guan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>cordova</title>
    <link href="http://yoursite.com/2018/10/24/cordova/"/>
    <id>http://yoursite.com/2018/10/24/cordova/</id>
    <published>2018-10-24T06:24:14.000Z</published>
    <updated>2018-10-24T08:35:44.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Cordova初探"><a href="#Cordova初探" class="headerlink" title="Cordova初探"></a>Cordova初探</h1><h2 id="Cordova是什么？"><a href="#Cordova是什么？" class="headerlink" title="Cordova是什么？"></a>Cordova是什么？</h2><p>Apache Cordova是开源移动端开发框架。它允许你使用标准的web技术 – HTML5,CSS3和JavaScript来跨平台开发。应用在与针对各平台（android,ios等）的容器中运行，可以使用与标准兼容的API来访问各个设备（如传感器、网络状态等）</p><h2 id="Cordova的结构"><a href="#Cordova的结构" class="headerlink" title="Cordova的结构"></a>Cordova的结构</h2><p>cordova 应用由多个部分组成。如下图<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cordova.apache.org/static/img/guide/cordovaapparchitecture.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="WebView"><a href="#WebView" class="headerlink" title="WebView"></a>WebView</h3><p>为应用提供所有用户接口，可以理解为浏览器</p><h3 id="Web-App"><a href="#Web-App" class="headerlink" title="Web App"></a>Web App</h3><p>即应用代码，html文件放在这里</p><h3 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h3><p>使得有能力通过js调用native code的能力</p><h2 id="安装搭建及遇到的问题"><a href="#安装搭建及遇到的问题" class="headerlink" title="安装搭建及遇到的问题"></a>安装搭建及遇到的问题</h2><p>1.全局安装cordova</p><p>npm install -g cordova </p><p>2.创建项目</p><p>cordova create hello com.example.hello HelloWorld</p><p>3.添加平台(以安卓为例)</p><p>cordova platform add android</p><p>4.环境检查</p><p>cordova requirements</p><p>问题：</p><p>a.Android SDK uninstalled</p><p>解决办法：下载android studio, 安装过程最好有vpn，这样不会有莫名其妙的问题</p><p>b.Android target问题</p><p>解决办法：在android studio中打开SDK Manager找到对应的target安装好</p><h2 id="生成App"><a href="#生成App" class="headerlink" title="生成App"></a>生成App</h2><p>cordova build</p><h2 id="Cordova-App更新问题"><a href="#Cordova-App更新问题" class="headerlink" title="Cordova App更新问题"></a>Cordova App更新问题</h2><p>可以使用cordova-hot-code-push-plugin热更新</p><p>使用方法：</p><p>1.添加插件： cordova plugin add cordova-hot-code-push-plugin</p><p>2.全局安装: npm install -g cordova-hot-code-push-cli</p><p>3.在服务器可访问路径下创建一个目录，比如：hotcode </p><p>4.在项目的根目录下新建一个cordova-hcp.json的文件添加以下内容</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"autogenerated"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"release"</span>: <span class="string">"2016.11.08-15.13.26"</span>,</span><br><span class="line">  <span class="attr">"content_url"</span>: <span class="string">"你的服务器访问路径/hotcode"</span>,</span><br><span class="line">  <span class="attr">"update"</span>: <span class="string">"now"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.在项目路径下运行cordova-hcp build，运行后会在www目录下生成chcp.json和chcp.manifest文件（必须）</p><p>6.将项目中的www目录下所有文件上传到服务起刚才新建的目录hotcode下面</p><p>7.将下面代码加入项目config.xml，然后运行cordova build android<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;chcp&gt;</span><br><span class="line">  &lt;config-file url=&quot; 你的服务器访问路径/hotcode/chcp.json&quot;/&gt;</span><br><span class="line">&lt;/chcp&gt;</span><br></pre></td></tr></table></figure></p><p>8.修改www目录下的内容，运行cordova-hcp build,将index.html和chcp.json和chcp.manifest上传至服务器对应的位置</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>配置好虚拟设备之后执行 cordova emulate android</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Cordova初探&quot;&gt;&lt;a href=&quot;#Cordova初探&quot; class=&quot;headerlink&quot; title=&quot;Cordova初探&quot;&gt;&lt;/a&gt;Cordova初探&lt;/h1&gt;&lt;h2 id=&quot;Cordova是什么？&quot;&gt;&lt;a href=&quot;#Cordova是什么？&quot; c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>移动端知识点汇总</title>
    <link href="http://yoursite.com/2018/03/06/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2018/03/06/移动端知识点汇总/</id>
    <published>2018-03-06T00:35:11.000Z</published>
    <updated>2018-10-24T06:02:47.826Z</updated>
    
    <content type="html"><![CDATA[<p>【原】移动web资源整理 <a href="http://www.cnblogs.com/PeunZhang/p/3407453.html" target="_blank" rel="noopener">http://www.cnblogs.com/PeunZhang/p/3407453.html</a></p><p>mobileTech <a href="https://github.com/jtyjty99999/mobileTech" target="_blank" rel="noopener">https://github.com/jtyjty99999/mobileTech</a></p><p>那些年我们一起切过的页面 <a href="http://www.maxzhang.com/2015/08/%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E4%B8%80%E8%B5%B7%E5%88%87%E8%BF%87%E7%9A%84%E9%A1%B5%E9%9D%A2/" target="_blank" rel="noopener">http://www.maxzhang.com/2015/08/%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E4%B8%80%E8%B5%B7%E5%88%87%E8%BF%87%E7%9A%84%E9%A1%B5%E9%9D%A2/</a></p><p>视差引擎 <a href="http://frozenui.github.io/frozenjs/effect/parallax/index.html" target="_blank" rel="noopener">http://frozenui.github.io/frozenjs/effect/parallax/index.html</a></p><p>轮菜单 <a href="http://www.jq22.com/jquery-info179" target="_blank" rel="noopener">http://www.jq22.com/jquery-info179</a></p><p>在微信、微博、QQ、Safari唤起App的解决方案 <a href="https://mp.weixin.qq.com/s/YAnlEBMZP_e91MXjPbAp-w" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/YAnlEBMZP_e91MXjPbAp-w</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;【原】移动web资源整理 &lt;a href=&quot;http://www.cnblogs.com/PeunZhang/p/3407453.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.cnblogs.com/PeunZhang/p/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>bfc</title>
    <link href="http://yoursite.com/2018/02/09/bfc/"/>
    <id>http://yoursite.com/2018/02/09/bfc/</id>
    <published>2018-02-09T07:18:43.000Z</published>
    <updated>2018-10-24T06:02:47.814Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>FC(Formatting Context)格式化上下文，是CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且由一套渲染规则，它决定<strong>子元素</strong>将如何定位，以及和<strong>其它元素</strong>的关系及相互作用。</p><p>BFC(Block Formatting Context)块级格式化上下文。<br>具有BFC特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且BFC具有普通容器没有的特性。<br>通俗来说可以把BFC理解为封闭的大箱子，箱子内部元素无论如何翻江倒海，都不会影响到外部。</p><h2 id="触发BFC"><a href="#触发BFC" class="headerlink" title="触发BFC"></a>触发BFC</h2><p>只要元素满足下面任一条件即可触发BFC特性：</p><ul><li>body根元素</li><li>浮动元素：float除none以外的值</li><li>绝对定位元素：position(absolute、fixed)</li><li>display为inline-block、table-cell、flex</li><li>overflow除了visible以外的值(hidden、auto、scroll)</li></ul><h2 id="BFC特性及应用"><a href="#BFC特性及应用" class="headerlink" title="BFC特性及应用"></a>BFC特性及应用</h2><ol><li><p>BFC可以包含浮动的元素（清除浮动）<br></p><p data-height="521" data-theme-id="dark" data-slug-hash="VQPNZQ" data-default-tab="result" data-user="JOHNNYGUAN" data-embed-version="2" data-pen-title="float" class="codepen">See the Pen <a href="https://codepen.io/JOHNNYGUAN/pen/VQPNZQ/" target="_blank" rel="noopener">float</a> by JOHNNY (<a href="https://codepen.io/JOHNNYGUAN" target="_blank" rel="noopener">@JOHNNYGUAN</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script></li><li><p>BFC可以阻止元素被浮动元素覆盖<br></p><p data-height="904" data-theme-id="dark" data-slug-hash="NydmxQ" data-default-tab="result" data-user="JOHNNYGUAN" data-embed-version="2" data-pen-title="float_overlap" class="codepen">See the Pen <a href="https://codepen.io/JOHNNYGUAN/pen/NydmxQ/" target="_blank" rel="noopener">float_overlap</a> by JOHNNY (<a href="https://codepen.io/JOHNNYGUAN" target="_blank" rel="noopener">@JOHNNYGUAN</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script></li></ol><p><strong>下图中形成bfc的元素可以防止浮动元素将其覆盖</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;FC(Formatting Context)格式化上下文，是CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且由一套渲染规则，它决
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>collapse margin</title>
    <link href="http://yoursite.com/2018/02/09/collapse-margin/"/>
    <id>http://yoursite.com/2018/02/09/collapse-margin/</id>
    <published>2018-02-09T06:48:09.000Z</published>
    <updated>2018-10-24T06:02:47.815Z</updated>
    
    <content type="html"><![CDATA[<p><code>有时候明明是在子元素上加margin-top，但是页面上显示的却是在父元素上加了margin-top。这是什么原因呢？</code></p><p></p><p data-height="335" data-theme-id="dark" data-slug-hash="rJjPoP" data-default-tab="result" data-user="JOHNNYGUAN" data-embed-version="2" data-pen-title="margin-top" class="codepen">See the Pen <a href="https://codepen.io/JOHNNYGUAN/pen/rJjPoP/" target="_blank" rel="noopener">margin-top</a> by JOHNNY (<a href="https://codepen.io/JOHNNYGUAN" target="_blank" rel="noopener">@JOHNNYGUAN</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script><br>这个问题是CSS2.1的盒模型中规定的内容——Collapsing margins：</p><p>In this specification, the expression collapsing margins means that adjoining margins (no non-empty content, padding or border areas or clearance separate them) of two or more boxes (which may be next to one another or nested) combine to form a single margin. 所有毗邻的两个或更多盒元素的margin将会合并为一个margin共享之。毗邻的定义为：<strong>同级或者嵌套的盒元素，并且它们之间没有非空内容、Padding或Border分隔</strong>。</p><p>也就是说父元素没有border、padding且父子元素之间没有非空内容时，父子元素的margin会合并，最终体现为父元素的margin。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;有时候明明是在子元素上加margin-top，但是页面上显示的却是在父元素上加了margin-top。这是什么原因呢？&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p data-height=&quot;335&quot; data-theme-id=&quot;dark&quot; data-slug-h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>addEventListener passive选项</title>
    <link href="http://yoursite.com/2018/02/07/addEventListener-passive%E9%80%89%E9%A1%B9/"/>
    <id>http://yoursite.com/2018/02/07/addEventListener-passive选项/</id>
    <published>2018-02-07T06:58:55.000Z</published>
    <updated>2018-10-24T06:02:47.796Z</updated>
    
    <content type="html"><![CDATA[<p>摘自 <a href="http://blog.csdn.net/dj0379/article/details/52883315" target="_blank" rel="noopener">http://blog.csdn.net/dj0379/article/details/52883315</a> </p><p>前文已经提过<em>addEventListener</em>有一个passive选项可以改善滚屏性能，本文将研究其中的原理。</p><p>当属性<em>passive</em>值为true的时候，Chrome称之为<strong>passive event listener</strong>。目前passive event listener支持mousewheel/touch相关事件。</p><h2 id="为何需要passive-event-listener"><a href="#为何需要passive-event-listener" class="headerlink" title="为何需要passive event listener"></a>为何需要passive event listener</h2><p>Passive Event Listeners特性是为了提高页面的滑动流畅度而设计的，页面滑动流畅度的提升，直接影响到用户对这个页面最直观的感受。Facebook之前做了一项试验，他们将页面滑动的响应刷新率从60FPS降低到30FPS的时候，发现用户的参与度急速下降。</p><h2 id="Chrome浏览器相关概念"><a href="#Chrome浏览器相关概念" class="headerlink" title="Chrome浏览器相关概念"></a>Chrome浏览器相关概念</h2><ol><li>绘制（Paint）：将绘制操作转换为图像（软件模式经过光栅化生成位图，硬件模式经过光栅化生成纹理）。在Chrome中，绘制分为两部分：绘制操作记录部分（main-thread side）和绘制实现部分（impl-side）。绘制记录部分将绘制操作记录到SKPicture，绘制实现部分将SKPicture进行光栅化转成图像。</li><li>图层（Paint Layer）：在Chrome中，页面的绘制是分层绘制的，页面内容变化的时候，浏览器仅需要重新绘制内容变化的图层，没有变化的图层不需要重新绘制。</li><li>合成（Composite）：将绘制好的图层图像混合在一起生产一张最终的图像显示在屏幕上。</li><li>渲染（Render）：可以简单认为渲染等价于绘制+合成。</li><li>UI线程（UI Thread）：浏览器主线程，负责接收系统派发给浏览器窗口的事件、资源下载等。</li><li>内核线程（Main/Render Thread）:Blink内核及V8引擎运行的线程，如DOM树构建、元素布局、绘制操作记录部分（main-thread side）、javascript执行逻辑等。</li><li>合成线程（Compositor Thread）：负责图像的合成，如绘制实现部分（impl-side）、合成等。</li></ol><h2 id="Chrome浏览器的线程化渲染框架"><a href="#Chrome浏览器的线程化渲染框架" class="headerlink" title="Chrome浏览器的线程化渲染框架"></a>Chrome浏览器的线程化渲染框架</h2><p>传统单线程渲染框架，内核线程包揽页面内容渲染的所有工作，如javascript执行，元素布局，图层绘制，图层图像合成等。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/02/07/addEventListener-passive选项/single.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这种框架有两个明显的问题：</p><ol><li>流水线的执行方式，后面的工作必须等待前面工作执行完成才能处理，无法将相互独立的工作并行处理；</li><li>内核线程负责的工作太多且耗时，一旦遇上内核在执行耗时较长的工作，用户的输入事件将无法立即得到响应。</li></ol><p>对于第一个问题，浏览器很难控制页面从内容变化到布局渲染整个过程的耗时，中间任何一项工作的执行都可能导致整体过程耗时变大，过大的耗时会导致页面内容的刷新率偏低，从而形成视觉上的卡顿。浏览器收到VSync中断信号通知的时候，意味着页面需要立即对内容进行渲染，如果内核线程可能还在执行业务javascript，页面渲染的内容无法立即开始，如果页面无法再下一个VSync中断信号到来之前完成对内容的渲染，则页面会出现丢帧，出现视觉体验的卡顿。</p><p><code>注：VSync信号中断的频率，一般跟设备屏幕的刷新率对齐，比如设备的刷新率为60FPS（Frame Per Second）,那么大概16.67ms会触发一下VSync中断信号。Chrome浏览器和Android系统等都是通过VSync中断信号来通知页面启动内容的渲染。</code><br>为了优化第一个问题，Chrome浏览器对内核线程负责的工作进行拆分，通过多线程并发处理提高渲染效率减少丢帧，如内核线程仅负责DOM树构建、元素的布局、图层绘制记录部分（main-thread side）、javascript执行，图层绘制实现部分（impl-side）、图层图像合成则交给合成线程负责处理。这种多线程负责页面内容的渲染框架，在Chrome中称为线程化渲染框架（Threaded Compositor Architecture）。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/02/07/addEventListener-passive选项/compositor.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>如上图所示，在Chrome的线程化渲染框架中，当内核线程完成第一帧的布局和记录绘制操作时，立即通知合成线程对第一帧进行渲染，然后内核线程就开始准备第2帧的布局和记录绘制操作。由此可以看出，内核线程在进行N+1帧的布局和记录绘制操作的同时，合成线程也在努力进行第N帧的渲染并交给屏幕展示。这里利用了CPU多核的特性进行并发处理，提高了页面的渲染效率。用户看到的页面内容是上一帧的内容快照，新的一帧还在处理中。</p><p>要优化第2个问题，对浏览器来说是非常困难的。只要输入事件要在内核线程执行逻辑，那么遇到内核线程在忙，必然无法立即得到响应。如用户的大部分输入事件都跟页面元素有关系，一旦页面元素注册了对应事件的监听器，监听器的逻辑代码（javascript）必须在内核线程中执行，这种输入事件经常无法立即得到响应。</p><p>有一些输入事件是可以不经过内核线程就能被快速处理的。在Chrome中，这类可以不经过内核线程就能快速处理的输入事件为手势输入事件（滑动、捏合），手势输入事件是由用户连续的普通输入事件组合产生，如连续的mousewheel/touchmove事件可能会生成GestureScrollBegin/GestrueScrollUpdate等手势事件。手势输入事件可以直接在已经渲染好的内容快照上操作，如滑动手势事件，直接对页面已经渲染好的内容快照进行滑动展示即可。由于线程化渲染框架的支持，手势输入事件可以不经过内核线程，直接有合成线程在内容快照上直接处理，所以即使此时内核线程在忙碌，用户的手势输入事件也可以马上得到响应。小demo可以验证Chrome的这个特性：如在一个有滚动条的页面内通过javascript执行一段死循环的代码（while-true），尝试上下滑动页面，你会发现此时页面仍能流畅地滑动。<br><code>注：感觉这段有问题。亲测在chrome中js加入死循环，页面卡死，页面并不会正常滚动。另外从MDN查询手势事件（GestureEvent），chrome并不支持手势事件。</code><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/02/07/addEventListener-passive选项/gesture_event.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/02/07/addEventListener-passive选项/compatibility.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在事件处理函数中加入占用内核线程的代码，在没有passive选项的情况下，页面滚动会有卡顿，而在passive为true的时候，页面滚动并不会受事件处理函数复杂度的影响。如下图所示，passive为true的时候，处理器滚动与事件处理函数不是串行的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/02/07/addEventListener-passive选项/dispatch.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘自 &lt;a href=&quot;http://blog.csdn.net/dj0379/article/details/52883315&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.csdn.net/dj0379/article/deta
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>addEventListener</title>
    <link href="http://yoursite.com/2018/02/07/addEventListener/"/>
    <id>http://yoursite.com/2018/02/07/addEventListener/</id>
    <published>2018-02-07T06:29:54.000Z</published>
    <updated>2018-10-24T06:02:47.806Z</updated>
    
    <content type="html"><![CDATA[<p>参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener</a></p><p>addEventListener是W3C DOM规范中提供的注册事件监听器的方法。</p><p>使用方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">target.addEventListener(type, listener, options);</span><br><span class="line"></span><br><span class="line">target.addEventListener(type, listener ,&#123;<span class="attr">capture</span>: <span class="built_in">Boolean</span>, <span class="attr">bubbling</span>: <span class="built_in">Boolean</span>, <span class="attr">once</span>: <span class="built_in">Boolean</span>&#125;);</span><br><span class="line"></span><br><span class="line">target.addEventListener(type, listener, useCapture);</span><br></pre></td></tr></table></figure></p><p>type和listener没啥特别的，这个方法我之前用的最多的是第三种形式，查看MDN才发现第三个参数还可以是对象。来看一下这个对象。</p><ul><li>capture:  Boolean，表示 listener 会在该类型的事件捕获阶段传播到该 EventTarget 时触发。</li><li>once:  Boolean，表示 listener 在添加之后最多只调用一次。如果是 true， listener 会在其被调用之后自动移除。</li><li>passive: Boolean，表示 listener 永远不会调用 preventDefault()。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。</li></ul><p><em>capture</em>与<em>useCapture</em>的效果一样。<br>使用<em>once</em>在调用事件处理函数之后会自动移除该事件监听，即只触发一次，效果与jQuery的$(dom).one(…)一致。<br><em>passive</em>则明确表示不会调用preventDefault()，如果依然调用，则被忽视。可以使用该参数改善滚屏性能。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">'elem'</span>); </span><br><span class="line">elem.addEventListener(<span class="string">'touchmove'</span>, <span class="function"><span class="keyword">function</span> <span class="title">listener</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* do something */</span> &#125;, &#123; <span class="attr">passive</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure></p><p>检测<em>passive</em>可以使用如下代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> passiveSupported = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> options = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">"passive"</span>, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      passiveSupported = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">"test"</span>, <span class="literal">null</span>, options);</span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>另外，<strong>对于相同的事件处理函数</strong>,addEventListener<strong>只会绑定一次</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ele.addEventListener(<span class="string">'click'</span>,handler,<span class="literal">false</span>);</span><br><span class="line">ele.addEventListener(<span class="string">'click'</span>,handler,<span class="literal">false</span>);<span class="comment">//只会绑一次</span></span><br><span class="line"></span><br><span class="line">ele.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line">ele.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;,<span class="literal">false</span>);<span class="comment">//两个匿名函数即使内容一样，也是两个不同的事件处理函数</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://develop
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>css shapes（译）</title>
    <link href="http://yoursite.com/2018/01/24/css-shapes/"/>
    <id>http://yoursite.com/2018/01/24/css-shapes/</id>
    <published>2018-01-24T03:14:53.000Z</published>
    <updated>2018-10-24T06:02:47.816Z</updated>
    
    <content type="html"><![CDATA[<p>由 <a href="http://alistapart.com/article/css-shapes-101" target="_blank" rel="noopener">http://alistapart.com/article/css-shapes-101</a> 翻译</p><p>矩形中套矩形：网页通常都是这个构成的。我们通过CSS创造<a href="https://css-tricks.com/examples/ShapesOfCSS/" target="_blank" rel="noopener">几何形状</a>来打破限制，但那些形状从未影响到被改变形状元素的内部。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">新的CSS Shapes规范改变了这个。在2012年年中由Adobe引入，它的目的是为设计者提供一种新方式来改变在任意复杂形状内部及周围的内容流动。之前不能做到。</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/01/24/css-shapes/shape-outside-example.jpg" alt="Notice how the text wraps around the circular shape of a bowl in this example. Using CSS Shapes, we can create similar designs for the web." title="">                </div>                <div class="image-caption">Notice how the text wraps around the circular shape of a bowl in this example. Using CSS Shapes, we can create similar designs for the web.</div>            </figure><h2 id="Creating-a-CSS-Shape"><a href="#Creating-a-CSS-Shape" class="headerlink" title="Creating a CSS Shape"></a>Creating a CSS Shape</h2><p>你可以使用Shapes的一个属性将shape应用到元素上。你将shape function作为值传给shape 属性。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/01/24/css-shapes/shape-rule.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>形状可以用以下函数中的一个来创建：</p><ul><li>circle()</li><li>ellipse()</li><li>inset()</li><li>polygon()</li></ul><p>接受以上值的形状属性有：</p><ul><li>shape-outside:在形状外包裹内容</li><li>shape-inside:在形状内包裹内容<strong>规范暂时不可使用</strong></li></ul><p>你可以结合<em>shape-margin</em>使用<em>shape-outside</em>，从而在shape外面增加外边距。对一个元素声明形状很简单：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line"><span class="attribute">shape-outside</span>: <span class="built_in">circle</span>(); <span class="comment">/* content will flow around the circle defined on the element */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line"><span class="attribute">shape-outside</span>: <span class="built_in">url</span>(path/to/image-with-shape.png);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然而还需要两个条件：</p><ol><li>元素必须是浮动的。</li><li>元素必须有内在维度（宽高）。<br>所以例子如下：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line"><span class="attribute">float</span>: left;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">10em</span>;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">15em</span>;</span><br><span class="line"><span class="attribute">shape-outside</span>: <span class="built_in">circle</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="A-Shape’s-reference-box"><a href="#A-Shape’s-reference-box" class="headerlink" title="A Shape’s reference box"></a>A Shape’s reference box</h2><p>CSS Shape 是在参考盒中定义和创建的，用于在元素上绘制形状。除了元素的高度和宽度，元素的盒模型–margin box,content box,padding box及border box也用于作为指定元素形状边界的参考。</p><p>默认，margin box用于作为参考，所以如果一个元素在底部有外边距，你在元素上定义的形状将触及margin 区域的边界，而不是border区域。如果你想要用其它的box值，你可以结合shape function指定shape属性：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">shape-outside</span>: <span class="selector-tag">circle</span>(250<span class="selector-tag">px</span> <span class="selector-tag">at</span> 50% 50%) <span class="selector-tag">padding-box</span>;</span><br></pre></td></tr></table></figure></p><h2 id="Defining-Shapes-using-shape-functions"><a href="#Defining-Shapes-using-shape-functions" class="headerlink" title="Defining Shapes using shape functions"></a>Defining Shapes using shape functions</h2><p></p><p data-height="265" data-theme-id="dark" data-slug-hash="KZjKEq" data-default-tab="result" data-user="JOHNNYGUAN" data-embed-version="2" data-pen-title="KZjKEq" class="codepen">See the Pen <a href="https://codepen.io/JOHNNYGUAN/pen/KZjKEq/" target="_blank" rel="noopener">KZjKEq</a> by JOHNNY (<a href="https://codepen.io/JOHNNYGUAN" target="_blank" rel="noopener">@JOHNNYGUAN</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script><h2 id="Defining-a-shape-using-an-image"><a href="#Defining-a-shape-using-an-image" class="headerlink" title="Defining a shape using an image"></a>Defining a shape using an image</h2><p>使用图像作为形状，这个图像需要有alpha通道，从而浏览器可以提取形状。<br>形状是由alpha值大于某一阈值的像素构成的。阈值默认是0.0（完全透明），你也可以通过<em>shape-image-shreshold</em>属性进行更改。</p><p>使用<em>url()</em>值指定<em>shape-outside</em>属性，我们可以将内容围绕在该形状周围。</p><div class="demo"><br>    <div style="width:64px; height:64px; float:left; background:blue; shape-outside: url(hot.png); mask-image:url(hot.png);-webkit-mask-image:url(hot.png)"></div><p style="margin: 0;">Lorem ipsum dolor sit amet, consectetur adipisicing elit. Harum itaque nam blanditiis eveniet enim eligendi quae adipisci?</p><p style="margin: 0;">Assumenda blanditiis voluptas tempore porro quibusdam beatae deleniti quod asperiores sapiente dolorem error! Quo nam quasi soluta reprehenderit laudantium optio ipsam ducimus consequatur enim fuga quibusdam mollitia nesciunt modi.</p><br></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由 &lt;a href=&quot;http://alistapart.com/article/css-shapes-101&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://alistapart.com/article/css-shapes-101&lt;/a&gt; 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>css motion paths（译）</title>
    <link href="http://yoursite.com/2018/01/24/css-motion-paths/"/>
    <id>http://yoursite.com/2018/01/24/css-motion-paths/</id>
    <published>2018-01-24T01:28:10.000Z</published>
    <updated>2018-10-24T06:02:47.815Z</updated>
    
    <content type="html"><![CDATA[<p>由<a href="https://codepen.io/danwilson/post/css-motion-paths" target="_blank" rel="noopener">https://codepen.io/danwilson/post/css-motion-paths</a> 翻译<br>当我开始<a href="http://danielcwilson.com/blog/2015/07/animations-intro/" target="_blank" rel="noopener">深入探索WAAPI</a>，最有趣的是即将支持Motion Paths(运动路径)–沿特定路径进行动画。在这儿的好处是不言而喻的，在没有它的时候，你要沿一条直线进行过渡，需要写一些keyframe，或者需要借助JS库来帮你抽取逻辑。虽然后者使事情变得简单，简单地在已有的CSS(或者WAAPI)动画中加入路径，仍然是很nice的。</p><p>Chrome最近声明他们对于<a href="https://www.w3.org/TR/motion-1/" target="_blank" rel="noopener">CSS Motion Path module</a>的<a href="https://www.chromestatus.com/features/6190642178818048" target="_blank" rel="noopener">原生支持</a></p><h2 id="我们怎样做到？"><a href="#我们怎样做到？" class="headerlink" title="我们怎样做到？"></a>我们怎样做到？</h2><p>在CSS和js中有三个新的<em>motion</em>属性，我们可以将其与transitions，CSS keyframe动画或者WAAPI结合。</p><h3 id="MOTION-PATH"><a href="#MOTION-PATH" class="headerlink" title="MOTION-PATH"></a>MOTION-PATH</h3><p>首先，<em>motion-path</em>定义运动的路径。你可以像在SVG1.1中定义路径一样来定义一条motion-path。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">motion-path: path(&quot;M200 200 S 200.5 200.1 348.7 184.4z&quot;);</span><br></pre></td></tr></table></figure></p><p>也可以接受<em>fill-rule</em>作为path中可选的第一个参数。你也可以使用诸如<em>circle</em>，<em>polygon</em>，<em>ellipse</em>和<em>inset</em>的基本形状。如果你使用过<a href="http://alistapart.com/article/css-shapes-101" target="_blank" rel="noopener">CSS Shapes</a>，你会对它很熟悉。最后你也可以通过<em>url()</em>引用形状。</p><p></p><p data-height="265" data-theme-id="dark" data-slug-hash="ZGmeRO" data-default-tab="css,result" data-user="danwilson" data-embed-version="2" data-pen-title="CSS Motion Path Spiral" class="codepen">See the Pen <a href="https://codepen.io/danwilson/pen/ZGmeRO/" target="_blank" rel="noopener">CSS Motion Path Spiral</a> by Dan Wilson (<a href="https://codepen.io/danwilson" target="_blank" rel="noopener">@danwilson</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script></p><h3 id="MOTION-OFFSET"><a href="#MOTION-OFFSET" class="headerlink" title="MOTION-OFFSET"></a>MOTION-OFFSET</h3><p>我们使用<em>motion-offset</em>指定物体出现的位置。它可以是一个double length value或者一个百分比。所以当我们沿路径从起始点运动到终点，我们创建一个从0到100%的动画。使用CSS keyframe:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@keyframes path-animation &#123;</span><br><span class="line">  0% &#123; </span><br><span class="line">    motion-offset: 0;</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123; </span><br><span class="line">    motion-offset: &apos;100%&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用WAAPI:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m.animate([</span><br><span class="line">    &#123; motionOffset: 0 &#125;,</span><br><span class="line">    &#123; motionOffset: &apos;100%&apos; &#125;</span><br><span class="line">], 1000);</span><br></pre></td></tr></table></figure></p><h3 id="MOTION-ROTATION"><a href="#MOTION-ROTATION" class="headerlink" title="MOTION-ROTATION"></a>MOTION-ROTATION</h3><p>物体面对的方向是由<em>motion-rotation</em>属性处理的。目前有4个主要的方式来处理：</p><ul><li>值”auto”意味着元素会随路径旋转。</li><li>值”reverse”指元素会随路径旋转，同时加上180度。</li><li>“auto Xdeg”（或者”reverse Xdeg”）会额外旋转一定角度。</li><li>“Xdeg”时物体会始终保持这个角度。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由&lt;a href=&quot;https://codepen.io/danwilson/post/css-motion-paths&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://codepen.io/danwilson/post/css-motion
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>web-animation-api tutorial4: GroupEffects &amp; SequenceEffects</title>
    <link href="http://yoursite.com/2018/01/23/web-animation-api-tutorial4-GroupEffects-SequenceEffects/"/>
    <id>http://yoursite.com/2018/01/23/web-animation-api-tutorial4-GroupEffects-SequenceEffects/</id>
    <published>2018-01-23T01:23:34.000Z</published>
    <updated>2018-10-24T06:02:47.824Z</updated>
    
    <content type="html"><![CDATA[<p>由<a href="http://danielcwilson.com/blog/2015/09/animations-part-4/" target="_blank" rel="noopener">http://danielcwilson.com/blog/2015/09/animations-part-4/</a>  翻译</p><p>我们继续讨论Web Animations API下的 <em>multiple animations</em>，实现群组和队列效果。</p><h2 id="KeyframeEffects"><a href="#KeyframeEffects" class="headerlink" title="KeyframeEffects"></a>KeyframeEffects</h2><p>一个KeyframeEffect接收三个参数：需要做动画的元素，keyframe数组以及时间选项。这个新的对象本质上是一个单独动画的蓝图，但我们讨论群组及队列动画的方式时，我们会接触它。它不会启动一个动画，它只是定义一个动画。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>);</span><br><span class="line"><span class="keyword">var</span> timings = &#123;</span><br><span class="line">  duration: <span class="number">1000</span>,</span><br><span class="line">  fill: <span class="string">'both'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> keyframes = [</span><br><span class="line">  &#123; <span class="attr">opacity</span>: <span class="number">1</span> &#125;.</span><br><span class="line">  &#123; <span class="attr">opacity</span>: <span class="number">0</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> effect = <span class="keyword">new</span> KeyframeEffect(elem, keyframes, timings);</span><br></pre></td></tr></table></figure></p><h2 id="GroupEffects"><a href="#GroupEffects" class="headerlink" title="GroupEffects"></a>GroupEffects</h2><p>虽然没有实现并且在Level1 spec也找不到，polyfill提供一种组合动画并将它们一起播放的方式。<em>GroupEffect</em>（即将在Level2 spec出现）将一个或更多的<em>KeyframeEffect</em>组合，用以同时播放。</p><p><em>GroupEffect</em>接收效果参数（代表多个动画的<em>KeyframeEffect</em>数组）。一旦定义，我们可以播放一组动画。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>);</span><br><span class="line"><span class="keyword">var</span> elem2 = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate2'</span>);</span><br><span class="line"><span class="keyword">var</span> timings = &#123;</span><br><span class="line">  duration: <span class="number">1000</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> keyframes = [</span><br><span class="line">  &#123; <span class="attr">opacity</span>: <span class="number">1</span> &#125;.</span><br><span class="line">  &#123; <span class="attr">opacity</span>: <span class="number">0</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> kEffects = [</span><br><span class="line">  <span class="keyword">new</span> KeyframeEffect(elem, keyframes, timings),</span><br><span class="line">  <span class="keyword">new</span> KeyframeEffect(elem2, keyframes, timings)</span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> group = <span class="keyword">new</span> GroupEffect(kEffects);</span><br><span class="line"><span class="built_in">document</span>.timeline.play(group);</span><br></pre></td></tr></table></figure><h2 id="SequenceEffects"><a href="#SequenceEffects" class="headerlink" title="SequenceEffects"></a>SequenceEffects</h2><p>与<em>GroupEffect</em>类似，<em>SequenceEffect</em>可以将动画一个接一个播放。你也可以一起使用<em>GroupEffect</em>和<em>SequenceEffect</em>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sequence = <span class="keyword">new</span> SequenceEffect(kEffects);</span><br><span class="line"><span class="built_in">document</span>.timeline.play(sequence);</span><br></pre></td></tr></table></figure></p><h2 id="创建动画的另一种方式"><a href="#创建动画的另一种方式" class="headerlink" title="创建动画的另一种方式"></a>创建动画的另一种方式</h2><p>火狐支持另一种方式：<em>Animation</em>构造函数。回顾我们之前的方式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>);</span><br><span class="line"><span class="keyword">var</span> timings = &#123;</span><br><span class="line">  duration: <span class="number">1000</span>,</span><br><span class="line">  fill: <span class="string">'both'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> keyframes = [</span><br><span class="line">  &#123; <span class="attr">opacity</span>: <span class="number">1</span> &#125;.</span><br><span class="line">  &#123; <span class="attr">opacity</span>: <span class="number">0</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">elem.animate(keyframes, timings);</span><br></pre></td></tr></table></figure></p><p>使用同样的变量，下面的代码与之等价<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> kEffect = <span class="keyword">new</span> KeyframeEffect(elem, keyframes, timings);</span><br><span class="line"><span class="keyword">var</span> player = <span class="keyword">new</span> Animation(kEffect, elem.ownerDocument.timeline);</span><br><span class="line">player.play();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//MDN查找代码如下</span></span><br><span class="line"><span class="keyword">var</span> cats = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.sharedTimelineCat'</span>);</span><br><span class="line">cats = <span class="built_in">Array</span>.prototype.slice.call(cats);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sharedTimeline = <span class="keyword">new</span> DocumentTimeline(&#123; <span class="attr">originTime</span>: <span class="number">500</span> &#125;);</span><br><span class="line"></span><br><span class="line">cats.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">cat</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> catKeyframes = <span class="keyword">new</span> KeyframeEffect(cat, keyframes, timing);</span><br><span class="line">  <span class="keyword">var</span> catAnimation = <span class="keyword">new</span> Animation(catKeyframes, sharedTimeline);</span><br><span class="line">  catAnimation.play(); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由&lt;a href=&quot;http://danielcwilson.com/blog/2015/09/animations-part-4/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://danielcwilson.com/blog/2015/09/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>web-animations-api-tutorial3-multiple-animations</title>
    <link href="http://yoursite.com/2018/01/22/web-animations-api-tutorial3-multiple-animations/"/>
    <id>http://yoursite.com/2018/01/22/web-animations-api-tutorial3-multiple-animations/</id>
    <published>2018-01-22T15:17:07.000Z</published>
    <updated>2018-10-24T06:02:47.825Z</updated>
    
    <content type="html"><![CDATA[<p>由<a href="http://danielcwilson.com/blog/2015/08/animations-part-3/" target="_blank" rel="noopener">http://danielcwilson.com/blog/2015/08/animations-part-3/</a>  翻译</p><p>我们讨论多个动画。</p><h2 id="每个元素上有多个动画"><a href="#每个元素上有多个动画" class="headerlink" title="每个元素上有多个动画"></a>每个元素上有多个动画</h2><p></p><p data-height="265" data-theme-id="0" data-slug-hash="dJrmJy" data-default-tab="js,result" data-user="JOHNNYGUAN" data-embed-version="2" data-pen-title="multi-animation" class="codepen">See the Pen <a href="https://codepen.io/JOHNNYGUAN/pen/dJrmJy/" target="_blank" rel="noopener">multi-animation</a> by JOHNNY (<a href="https://codepen.io/JOHNNYGUAN" target="_blank" rel="noopener">@JOHNNYGUAN</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script><p>在这个例子中，每个矩形应用了三个动画（改变transform、opacity和color）。你可以在一个元素上多次调用<em>animate()</em>，这与CSS上使用多个动画是类似的。</p><p>使用CSS时：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#toAnimate &#123;</span><br><span class="line">  animation: pulse <span class="number">1</span>s, activate <span class="number">3000</span>ms, have-fun-<span class="keyword">with</span>-it <span class="number">2.5</span>s;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes pulse &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">@keyframes activate &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">@keyframes have-fun-<span class="keyword">with</span>-it &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure></p><p>使用Web Animations API<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> animated = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>);</span><br><span class="line"><span class="keyword">var</span> pulseKeyframes, <span class="comment">//defined the keyframes here.</span></span><br><span class="line">    activateKeyframes,</span><br><span class="line">    haveFunKeyframes;</span><br><span class="line"><span class="keyword">var</span> pulse = animated.animate(pulseKeyframes, <span class="number">1000</span>); <span class="comment">//the second parameter as a number is a valid shorthand for duration</span></span><br><span class="line"><span class="keyword">var</span> activate = animated.animate(activateKeyframes, <span class="number">3000</span>);</span><br><span class="line"><span class="keyword">var</span> haveFunWithIt = animated.animate(haveFunKeyframes, <span class="number">2500</span>);</span><br></pre></td></tr></table></figure></p><p>使用Web Animations API时，创造了三个<em>Animation</em>对象，它们可以被暂停，播放，完成，取消以及通过时间线或播放速率进行操作。</p><h2 id="Get-the-AnimationS-Get-Them-All"><a href="#Get-the-AnimationS-Get-Them-All" class="headerlink" title="Get the AnimationS,Get Them All"></a>Get the AnimationS,Get Them All</h2><p>当你在调用<em>animate()</em>时没有保存<em>Animation</em>引用时，应该做什么？<br>规范规定在document上有一个<em>getAnimations()</em>方法。在最新版本的规范，这个方法直接在document对象上，火狐48+也是这么实现的。但是Chrome52以及polyfill(v2.2.0)，是根据旧规范实现的，这个方法在timeline对象上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//If including the polyfill you can use the following</span></span><br><span class="line"><span class="keyword">var</span> animations = <span class="built_in">document</span>.getAnimations ? <span class="built_in">document</span>.getAnimations() : <span class="built_in">document</span>.timeline.getAnimations();</span><br><span class="line"><span class="comment">//returns array of all active (not finished and not canceled) animations</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由&lt;a href=&quot;http://danielcwilson.com/blog/2015/08/animations-part-3/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://danielcwilson.com/blog/2015/08/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>web-animation-api tutorial2: the animation &amp; timeline controls</title>
    <link href="http://yoursite.com/2018/01/22/web-animation-api-tutorial2-the-animation-timeline-controls/"/>
    <id>http://yoursite.com/2018/01/22/web-animation-api-tutorial2-the-animation-timeline-controls/</id>
    <published>2018-01-22T10:49:09.000Z</published>
    <updated>2018-10-24T06:02:47.823Z</updated>
    
    <content type="html"><![CDATA[<p>由<a href="http://danielcwilson.com/blog/2015/07/animations-part-2/" target="_blank" rel="noopener">http://danielcwilson.com/blog/2015/07/animations-part-2/</a>  翻译<br>现在我们理解了如何使用Web Animations API，我们再讨论一下状态、控制、回调及时间线。</p><h2 id="动画播放状态和控制"><a href="#动画播放状态和控制" class="headerlink" title="动画播放状态和控制"></a>动画播放状态和控制</h2><p>当调用<em>element.animate()</em>时，会返回一个<em>Animation</em>对象，动画随机开始播放。为了解动画的当前状态，你可以查看只读属性<em>playState</em>，它会返回5个字符串之一。我们也能够通过调用4个方法之一来修改动画的当前状态：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> player = element.animate(<span class="comment">/* ... */</span>);</span><br><span class="line"><span class="built_in">console</span>.log(player.playState); <span class="comment">//"running"</span></span><br><span class="line"></span><br><span class="line">player.pause(); <span class="comment">//"paused"</span></span><br><span class="line">player.play();  <span class="comment">//"running"</span></span><br><span class="line">player.cancel(); <span class="comment">//"idle"... jump to original state</span></span><br><span class="line">player.finish(); <span class="comment">//"finished"...jump to end state</span></span><br></pre></td></tr></table></figure></p><p>除了<em>running,paused,idle</em>和<em>finished</em>的播放状态，还定义了<em>pending</em>状态，这会在播放状态或暂停状态未决时发生。</p><h2 id="播放速率"><a href="#播放速率" class="headerlink" title="播放速率"></a>播放速率</h2><p>通过<em>playbackRate</em>属性来改变播放速率。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> player = element.animate(<span class="comment">/* ... */</span>);</span><br><span class="line"><span class="built_in">console</span>.log(player.playbackRate); <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">player.playbackRate = <span class="number">2</span>; <span class="comment">//double speed, can also be decimal to slow it down.</span></span><br></pre></td></tr></table></figure></p><h2 id="完成回调"><a href="#完成回调" class="headerlink" title="完成回调"></a>完成回调</h2><p>使用CSS过渡，当过渡结束时会触发事件。类似地，<em>Animation</em>会在动画完成或者调用finish()。注意根据规范，无限次循环的动画集是不能终止的，播放率也不能设为0。也有<em>oncancel</em>句柄，以及<em>Animation</em>完成时使用Promise的选项。</p><h2 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h2><p>每个<em>Animation</em>暴露出两个读/写时间相关的属性–<em>currentTime</em>和<em>startTime</em>。现在我们关注前者。</p><p><em>currentTime</em>返回动画目前的毫秒数。最大值是<em>delay + (duration </em> iterations)*，所以无限循环不会有最大值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> player = element.animate([</span><br><span class="line">  &#123;<span class="attr">opacity</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">opacity</span>: <span class="number">0</span>&#125;</span><br><span class="line">], &#123;</span><br><span class="line">  duration: <span class="number">1000</span>,</span><br><span class="line">  delay: <span class="number">500</span>,</span><br><span class="line">  iterations: <span class="number">3</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">player.onfinish = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(player.currentTime); <span class="comment">// 3500</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>播放速率会影响到时间线进展的快慢。如果将播放速率设为10，最大currentTime不变，但是整个时间线会缩短为1/10。</p><p>由于<em>currentTime</em>是读/写的，我们可以使用这个跳跃到时间线的某个点。它也可以用来同步两个动画。</p><h2 id="另一个选项：reverse"><a href="#另一个选项：reverse" class="headerlink" title="另一个选项：reverse()"></a>另一个选项：reverse()</h2><p>你也可以使用<em>reverse()</em>来反转一个动画，这与<em>play()</em>相似，但是会逆时间线发展。当动画完成时<em>currentTime</em>会是0。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由&lt;a href=&quot;http://danielcwilson.com/blog/2015/07/animations-part-2/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://danielcwilson.com/blog/2015/07/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>web-animation-api tutorial1: creating a basic animation</title>
    <link href="http://yoursite.com/2018/01/22/web-animation-api-tutorial1-creating-a-basic-animation/"/>
    <id>http://yoursite.com/2018/01/22/web-animation-api-tutorial1-creating-a-basic-animation/</id>
    <published>2018-01-22T05:49:56.000Z</published>
    <updated>2018-10-24T06:02:47.822Z</updated>
    
    <content type="html"><![CDATA[<p>由<a href="http://danielcwilson.com/blog/2015/07/animations-part-1/" target="_blank" rel="noopener">http://danielcwilson.com/blog/2015/07/animations-part-1/</a>  翻译</p><p>我们已经大致了解了Web Animation API，现在我们深入学习一下真实规范。</p><p>WAAPI让你能够比使用CSS动画做更多的控制，我们首先使用这个API做一个基本动画。</p><h2 id="构建关键帧动画"><a href="#构建关键帧动画" class="headerlink" title="构建关键帧动画"></a>构建关键帧动画</h2><p>如果你对CSS过渡/动画熟悉，它看起来会很类似。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> player = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>).animate([</span><br><span class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(1)'</span>, <span class="attr">opacity</span>: <span class="number">1</span>, <span class="attr">offset</span>: <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(.5)'</span>, <span class="attr">opacity</span>: <span class="number">.5</span>, <span class="attr">offset</span>: <span class="number">.3</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(.667)'</span>, <span class="attr">opacity</span>: <span class="number">.667</span>, <span class="attr">offset</span>: <span class="number">.7875</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(.6)'</span>, <span class="attr">opacity</span>: <span class="number">.6</span>, <span class="attr">offset</span>: <span class="number">1</span> &#125;</span><br><span class="line">  ], &#123;</span><br><span class="line">    duration: <span class="number">700</span>, <span class="comment">//milliseconds</span></span><br><span class="line">    easing: <span class="string">'ease-in-out'</span>, <span class="comment">//'linear', a bezier curve, etc.</span></span><br><span class="line">    delay: <span class="number">10</span>, <span class="comment">//milliseconds</span></span><br><span class="line">    iterations: <span class="literal">Infinity</span>, <span class="comment">//or a number</span></span><br><span class="line">    direction: <span class="string">'alternate'</span>, <span class="comment">//'normal', 'reverse', etc.</span></span><br><span class="line">    fill: <span class="string">'forwards'</span> <span class="comment">//'backwards', 'both', 'none', 'auto'</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p><p>为了对比起见，有一个同等的CSS关键帧动画。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@keyframes emphasis &#123;</span><br><span class="line">  <span class="number">0</span>% &#123;</span><br><span class="line">    transform: scale(<span class="number">1</span>); </span><br><span class="line">    opacity: <span class="number">1</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">30</span>% &#123;</span><br><span class="line">    transform: scale(<span class="number">.5</span>); </span><br><span class="line">    opacity: <span class="number">.5</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">78.75</span>% &#123;</span><br><span class="line">    transform: scale(<span class="number">.667</span>); </span><br><span class="line">    opacity: <span class="number">.667</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100</span>% &#123;</span><br><span class="line">    transform: scale(<span class="number">.6</span>);</span><br><span class="line">    opacity: <span class="number">.6</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">#toAnimate &#123;</span><br><span class="line">  animation: emphasis <span class="number">700</span>ms ease-<span class="keyword">in</span>-out <span class="number">10</span>ms infinite alternate forwards;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们将这个动画分解并对各个部分进行解释。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> player = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>).animate()</span><br></pre></td></tr></table></figure></p><p>这个动画会返回一个<em>Animation</em>对象，我们之后会用它做一些有趣的事，因而要用一个变量将其保存。我们找到想要做动画的元素（这里用<em>document.getElementById</em>获取），调用<em>animate</em>函数。这个函数是新加进规范的，所以你需要测试支持性，或者引入polyfill。</p><p><em>animate</em>函数接收两个参数，一个关键帧效果(<em>KeyframeEffect</em>)数组，一个动画效果时间属性（<em>AnimationEffectTimingProperties</em>）选项。从本质上来看，第一个参数映射为你想要再CSS@keyframes中放置的参数，第二个参数则是你想通过<em>animation-</em>属性指定的CSS规则。这里的关键益处在于我们能够使用变量，或者重复使用预先定义的<em>KeyframeEffect</em>，而在CSS中，我们会受限于我们声明的CSS值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> player = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>).animate([</span><br><span class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(1)'</span>, <span class="attr">opacity</span>: <span class="number">1</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(.5)'</span>, <span class="attr">opacity</span>: <span class="number">.5</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(.667)'</span>, <span class="attr">opacity</span>: <span class="number">.667</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">transform</span>: <span class="string">'scale(.6)'</span>, <span class="attr">opacity</span>: <span class="number">.6</span> &#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>对于每个<em>KeyframeEffect</em>，我们将CSS中的offset值变为0-1之间的小数offset值。它是可选的，如果你不指定，它们会均匀分布。你也可以指定<em>easing</em>属性，效果与CSS中的<em>animmation-timing-function</em>一致。其它<em>KeyframeEffect</em>中的属性是animate中的属性。每个属性的值应该与你在javascript中使用<em>element.style</em>指定保持一致，所以<em>opacity</em>是数字，<em>transform</em>是字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> player = <span class="built_in">document</span>.getElementById(<span class="string">'toAnimate'</span>).animate([], &#123;</span><br><span class="line">    duration: <span class="number">700</span>, <span class="comment">//milliseconds</span></span><br><span class="line">    easing: <span class="string">'ease-in-out'</span>, <span class="comment">//'linear', a bezier curve, etc.</span></span><br><span class="line">    delay: <span class="number">10</span>, <span class="comment">//milliseconds</span></span><br><span class="line">    iterations: <span class="literal">Infinity</span>, <span class="comment">//or a number</span></span><br><span class="line">    direction: <span class="string">'alternate'</span>, <span class="comment">//'normal', 'reverse', etc.</span></span><br><span class="line">    fill: <span class="string">'forwards'</span> <span class="comment">//'backwards', 'both', 'none', 'auto'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p data-height="265" data-theme-id="dark" data-slug-hash="eyXdoZ" data-default-tab="css,result" data-user="JOHNNYGUAN" data-embed-version="2" data-pen-title="animation" class="codepen">See the Pen <a href="https://codepen.io/JOHNNYGUAN/pen/eyXdoZ/" target="_blank" rel="noopener">animation</a> by JOHNNY (<a href="https://codepen.io/JOHNNYGUAN" target="_blank" rel="noopener">@JOHNNYGUAN</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由&lt;a href=&quot;http://danielcwilson.com/blog/2015/07/animations-part-1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://danielcwilson.com/blog/2015/07/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>web animations api（译）</title>
    <link href="http://yoursite.com/2018/01/22/web-animations-api/"/>
    <id>http://yoursite.com/2018/01/22/web-animations-api/</id>
    <published>2018-01-22T02:36:38.000Z</published>
    <updated>2018-10-24T06:02:47.825Z</updated>
    
    <content type="html"><![CDATA[<p>由<a href="http://danielcwilson.com/blog/2015/07/animations-intro/" target="_blank" rel="noopener">http://danielcwilson.com/blog/2015/07/animations-intro/</a> 翻译</p><h1 id="Let’s-talk-about-the-Web-Animations-API"><a href="#Let’s-talk-about-the-Web-Animations-API" class="headerlink" title="Let’s talk about the Web Animations API"></a>Let’s talk about the Web Animations API</h1><p>在2014年夏天，谷歌在网上通过Polymer宣告Material design..使用了即将来临的Web Animations API标准的polyfill。</p><p>我从未听过这个API，但是我被吸引了，尤其是因为它讨论了MotionPath效果。它还没有完成，但是它提供一种统一CSS、JS和SVG方式来做动画的目的吸引了我。一年后，谷歌和火狐开始实现该标准，polyfill的进程也已经稳定，是时候认真地看待它了。</p><p>但是很少有人讨论WAAPI！我希望现在通过写一系列文章，突出它在浏览器中的特色，探索我们为什么想要这个API，搞清楚它们的细微差别。</p><h2 id="什么是Web-Animation-API"><a href="#什么是Web-Animation-API" class="headerlink" title="什么是Web Animation API"></a>什么是Web Animation API</h2><p>我们通过弄清它是什么及它想要实现什么来开始这次探索。</p><p>动画在过去5年进展很好，有很好的CSS支持以及对javascript的支持。但是在它们提供很多好处的同时，仍然有大量的缺点。</p><ul><li>CSS拥有对于平滑过渡的硬件加速，并且是内置于浏览器中的。但是它的规则是在CSS中声明，需要很费劲的使用javascript来动态改变值。</li><li><em>requestAnimationFrame</em>拥有很好的支持，会让浏览器优化何时开始动画，但它仍然可能在有大量其它js运行的时候挂起。它也需要更多的数学来倒计时。</li><li><em>setInterval</em>将很多开发者引入到动画中，但它是不精确的，也会导致不流畅的动画。</li><li><em>jQuery.animate()</em>将其它一些开发者带入动画，但通常会有性能问题。</li><li>诸如Velocity和GreenSock(GSAP)提升了js性能，并且在很多场景下测试显示为最佳。但是，它们需要维护并且引入外部库。</li></ul><p>通常来说，我们喜欢浏览器尽可能支持并且由浏览器进行优化。浏览器现在有<em>document.querySelector</em>，因为我们看到jQuery提供这种选择DOM元素的方式。所以库中的功能被迁移到浏览器中。理想情况，我们能够将尽可能多的动画控制放在浏览器层面。这些库就可以专注于新特性，然后良性循环。</p><p>Web Animation API致力于此。它旨在带来CSS性能方面的能力，加上js的便利和灵活性。</p><h2 id="让我们加一些新东西来解决问题"><a href="#让我们加一些新东西来解决问题" class="headerlink" title="让我们加一些新东西来解决问题"></a>让我们加一些新东西来解决问题</h2><p>在前一份工作，我们收到一份邮件，说他们知道我们在公司事务方面有太多的地方需要查看 – email，办公室监视器，Yammer， Google Chat及intranet/wiki。为解决这个问题，他们加了一个博客。</p><p>当我第一次听到Web Animation API的时候，我的想法和我听到我公司要加博客时一样 – 它只会让事情变得更糟。这个博客没有中心化任何事物，它仅仅是额外增加了我们要查看新闻的地方，然后它死掉了。</p><p>但是这个感觉是不一样的。规范展示了它的关注点。它不是为了替代已有的行为，而是要统一。语法类似CSS，但是增加了变量、控制和完成回调的选项。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由&lt;a href=&quot;http://danielcwilson.com/blog/2015/07/animations-intro/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://danielcwilson.com/blog/2015/07/a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>atan与atan2(译 wikipedia)</title>
    <link href="http://yoursite.com/2018/01/06/atan%E4%B8%8Eatan2/"/>
    <id>http://yoursite.com/2018/01/06/atan与atan2/</id>
    <published>2018-01-06T05:25:27.000Z</published>
    <updated>2018-10-24T06:02:47.807Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><p>很多计算机语言都提供了以<em>atan2(y,x)</em>或<em>arctan2(y,x)</em>为名的多值反正切函数。这个函数接受两个参数<em>y</em>和<em>x</em>（不能同时为0，代表<em>X/Y</em>平面中除原点外的任意点<em>(x,y)</em>）。比例<em>y/x</em>为原点到该点的射线与x轴的夹角角<em>&theta;</em>。返回的弧度角封闭在区间(-π,π],并且在<em>y&gt;0</em>时值为正。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/01/06/atan与atan2/Arctangent2.svg" alt="Graph of atan2(y,x) over y/x" title="">                </div>                <div class="image-caption">Graph of atan2(y,x) over y/x</div>            </figure><figure class="image-bubble"><br>    <div class="img-lightbox"><br>        <div class="overlay"></div><br>        <img src="/2018/01/06//atan%E4%B8%8Eatan2/Atan2_argument_sign_graph.svg" alt="Graph of the tangent function from −π to +π with the corresponding signs of y over x" title="" width="450"><br>    </div><br>    <div class="image-caption">Graph of the tangent function from −π to +π with the corresponding signs of y over x</div><br></figure><h2 id="历史与动机"><a href="#历史与动机" class="headerlink" title="历史与动机"></a>历史与动机</h2><p><em>atan2</em>函数首先是在计算机编程语言中引入的，但现在它在科学及工程领域也很常用。它至少可以追溯到<strong>FORTRAN</strong>编程语言，现在可以在很多现代编程语言中找到。其中有C语言的math.h 标准库，Java Math库，.NET的System.Math，Python的math模块等。</p><p>接受一个参数的arctangent函数不能直接区分相对方向。例如，从x轴到向量(1,1)的逆时针角，记为 <em>arctan(1/1)</em>，为π/4弧度或45°。然而，x轴与向量(-1,-1)之间的夹角，为<em>arctan(-1/-1)</em>，但却不是π/4弧度。另外。在求x轴与向量(0,y),y≠0的时候，需要计算<em>arctan(y/0)</em>，但是分母不能为0。</p><p>相比之下，<em>arctan2</em>函数可以通过两个变量<em>y</em>和<em>x</em>计算出唯一的反正切值。</p><h2 id="定义与计算"><a href="#定义与计算" class="headerlink" title="定义与计算"></a>定义与计算</h2><p>根据标准反正切函数，<em>arctan2</em>函数可以表示为<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/01/06/atan与atan2/f1.svg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/01/06/atan与atan2/f2.svg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/01/06/atan与atan2/f3.svg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/01/06/atan与atan2/f4.svg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概论&quot;&gt;&lt;a href=&quot;#概论&quot; class=&quot;headerlink&quot; title=&quot;概论&quot;&gt;&lt;/a&gt;概论&lt;/h2&gt;&lt;p&gt;很多计算机语言都提供了以&lt;em&gt;atan2(y,x)&lt;/em&gt;或&lt;em&gt;arctan2(y,x)&lt;/em&gt;为名的多值反正切函数。这个函数接受
      
    
    </summary>
    
    
      <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
</feed>
