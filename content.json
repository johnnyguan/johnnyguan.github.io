{"meta":{"title":"JOHN'S BLOG","subtitle":null,"description":null,"author":"Johnny Guan","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-01-06T10:14:45.000Z","updated":"2018-10-24T06:02:47.827Z","comments":true,"path":"categories/index-1.html","permalink":"http://yoursite.com/categories/index-1.html","excerpt":"","text":""},{"title":"categories","date":"2018-01-06T10:13:58.000Z","updated":"2018-10-24T06:02:47.828Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-01-06T10:10:58.000Z","updated":"2018-10-24T06:02:47.829Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"cordova","slug":"cordova","date":"2018-10-24T06:24:14.000Z","updated":"2018-10-24T07:48:58.590Z","comments":true,"path":"2018/10/24/cordova/","link":"","permalink":"http://yoursite.com/2018/10/24/cordova/","excerpt":"","text":"Cordova初探Cordova是什么？Apache Cordova是开源移动端开发框架。它允许你使用标准的web技术 – HTML5,CSS3和JavaScript来跨平台开发。应用在与针对各平台（android,ios等）的容器中运行，可以使用与标准兼容的API来访问各个设备（如传感器、网络状态等） Cordova的结构cordova 应用由多个部分组成。如下图 WebView为应用提供所有用户接口，可以理解为浏览器 Web App即应用代码，html文件放在这里 Plugins使得有能力通过js调用native code的能力 安装搭建及遇到的问题1.全局安装cordova npm install -g cordova 2.创建项目 cordova create hello com.example.hello HelloWorld 3.添加平台(以安卓为例) cordova platform add android 4.环境检查 cordova requirements 问题： a.Android SDK uninstalled 解决办法：下载android studio, 安装过程最好有vpn，这样不会有莫名其妙的问题 b.Android target问题 解决办法：在android studio中打开SDK Manager找到对应的target安装好 生成Appcordova build Cordova App更新问题可以使用cordova-hot-code-push-plugin热更新 使用方法： 1.添加插件： cordova plugin add cordova-hot-code-push-plugin 2.全局安装: npm install -g cordova-hot-code-push-cli 3.在服务器可访问路径下创建一个目录，比如：hotcode 4.在项目的根目录下新建一个cordova-hcp.json的文件添加以下内容","categories":[],"tags":[]},{"title":"移动端知识点汇总","slug":"移动端知识点汇总","date":"2018-03-06T00:35:11.000Z","updated":"2018-10-24T06:02:47.826Z","comments":true,"path":"2018/03/06/移动端知识点汇总/","link":"","permalink":"http://yoursite.com/2018/03/06/移动端知识点汇总/","excerpt":"","text":"【原】移动web资源整理 http://www.cnblogs.com/PeunZhang/p/3407453.html mobileTech https://github.com/jtyjty99999/mobileTech 那些年我们一起切过的页面 http://www.maxzhang.com/2015/08/%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E4%B8%80%E8%B5%B7%E5%88%87%E8%BF%87%E7%9A%84%E9%A1%B5%E9%9D%A2/ 视差引擎 http://frozenui.github.io/frozenjs/effect/parallax/index.html 轮菜单 http://www.jq22.com/jquery-info179 在微信、微博、QQ、Safari唤起App的解决方案 https://mp.weixin.qq.com/s/YAnlEBMZP_e91MXjPbAp-w","categories":[],"tags":[]},{"title":"bfc","slug":"bfc","date":"2018-02-09T07:18:43.000Z","updated":"2018-10-24T06:02:47.814Z","comments":true,"path":"2018/02/09/bfc/","link":"","permalink":"http://yoursite.com/2018/02/09/bfc/","excerpt":"","text":"概念FC(Formatting Context)格式化上下文，是CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且由一套渲染规则，它决定子元素将如何定位，以及和其它元素的关系及相互作用。 BFC(Block Formatting Context)块级格式化上下文。具有BFC特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且BFC具有普通容器没有的特性。通俗来说可以把BFC理解为封闭的大箱子，箱子内部元素无论如何翻江倒海，都不会影响到外部。 触发BFC只要元素满足下面任一条件即可触发BFC特性： body根元素 浮动元素：float除none以外的值 绝对定位元素：position(absolute、fixed) display为inline-block、table-cell、flex overflow除了visible以外的值(hidden、auto、scroll) BFC特性及应用 BFC可以包含浮动的元素（清除浮动）See the Pen float by JOHNNY (@JOHNNYGUAN) on CodePen. BFC可以阻止元素被浮动元素覆盖See the Pen float_overlap by JOHNNY (@JOHNNYGUAN) on CodePen. 下图中形成bfc的元素可以防止浮动元素将其覆盖","categories":[],"tags":[]},{"title":"collapse margin","slug":"collapse-margin","date":"2018-02-09T06:48:09.000Z","updated":"2018-10-24T06:02:47.815Z","comments":true,"path":"2018/02/09/collapse-margin/","link":"","permalink":"http://yoursite.com/2018/02/09/collapse-margin/","excerpt":"","text":"有时候明明是在子元素上加margin-top，但是页面上显示的却是在父元素上加了margin-top。这是什么原因呢？ See the Pen margin-top by JOHNNY (@JOHNNYGUAN) on CodePen. 这个问题是CSS2.1的盒模型中规定的内容——Collapsing margins： In this specification, the expression collapsing margins means that adjoining margins (no non-empty content, padding or border areas or clearance separate them) of two or more boxes (which may be next to one another or nested) combine to form a single margin. 所有毗邻的两个或更多盒元素的margin将会合并为一个margin共享之。毗邻的定义为：同级或者嵌套的盒元素，并且它们之间没有非空内容、Padding或Border分隔。 也就是说父元素没有border、padding且父子元素之间没有非空内容时，父子元素的margin会合并，最终体现为父元素的margin。","categories":[],"tags":[]},{"title":"addEventListener passive选项","slug":"addEventListener-passive选项","date":"2018-02-07T06:58:55.000Z","updated":"2018-10-24T06:02:47.796Z","comments":true,"path":"2018/02/07/addEventListener-passive选项/","link":"","permalink":"http://yoursite.com/2018/02/07/addEventListener-passive选项/","excerpt":"","text":"摘自 http://blog.csdn.net/dj0379/article/details/52883315 前文已经提过addEventListener有一个passive选项可以改善滚屏性能，本文将研究其中的原理。 当属性passive值为true的时候，Chrome称之为passive event listener。目前passive event listener支持mousewheel/touch相关事件。 为何需要passive event listenerPassive Event Listeners特性是为了提高页面的滑动流畅度而设计的，页面滑动流畅度的提升，直接影响到用户对这个页面最直观的感受。Facebook之前做了一项试验，他们将页面滑动的响应刷新率从60FPS降低到30FPS的时候，发现用户的参与度急速下降。 Chrome浏览器相关概念 绘制（Paint）：将绘制操作转换为图像（软件模式经过光栅化生成位图，硬件模式经过光栅化生成纹理）。在Chrome中，绘制分为两部分：绘制操作记录部分（main-thread side）和绘制实现部分（impl-side）。绘制记录部分将绘制操作记录到SKPicture，绘制实现部分将SKPicture进行光栅化转成图像。 图层（Paint Layer）：在Chrome中，页面的绘制是分层绘制的，页面内容变化的时候，浏览器仅需要重新绘制内容变化的图层，没有变化的图层不需要重新绘制。 合成（Composite）：将绘制好的图层图像混合在一起生产一张最终的图像显示在屏幕上。 渲染（Render）：可以简单认为渲染等价于绘制+合成。 UI线程（UI Thread）：浏览器主线程，负责接收系统派发给浏览器窗口的事件、资源下载等。 内核线程（Main/Render Thread）:Blink内核及V8引擎运行的线程，如DOM树构建、元素布局、绘制操作记录部分（main-thread side）、javascript执行逻辑等。 合成线程（Compositor Thread）：负责图像的合成，如绘制实现部分（impl-side）、合成等。 Chrome浏览器的线程化渲染框架传统单线程渲染框架，内核线程包揽页面内容渲染的所有工作，如javascript执行，元素布局，图层绘制，图层图像合成等。 这种框架有两个明显的问题： 流水线的执行方式，后面的工作必须等待前面工作执行完成才能处理，无法将相互独立的工作并行处理； 内核线程负责的工作太多且耗时，一旦遇上内核在执行耗时较长的工作，用户的输入事件将无法立即得到响应。 对于第一个问题，浏览器很难控制页面从内容变化到布局渲染整个过程的耗时，中间任何一项工作的执行都可能导致整体过程耗时变大，过大的耗时会导致页面内容的刷新率偏低，从而形成视觉上的卡顿。浏览器收到VSync中断信号通知的时候，意味着页面需要立即对内容进行渲染，如果内核线程可能还在执行业务javascript，页面渲染的内容无法立即开始，如果页面无法再下一个VSync中断信号到来之前完成对内容的渲染，则页面会出现丢帧，出现视觉体验的卡顿。 注：VSync信号中断的频率，一般跟设备屏幕的刷新率对齐，比如设备的刷新率为60FPS（Frame Per Second）, 那么大概16.67ms会触发一下VSync中断信号。Chrome浏览器和Android系统等都是通过VSync中断信号来通知页面启动内容的渲染。为了优化第一个问题，Chrome浏览器对内核线程负责的工作进行拆分，通过多线程并发处理提高渲染效率减少丢帧，如内核线程仅负责DOM树构建、元素的布局、图层绘制记录部分（main-thread side）、javascript执行，图层绘制实现部分（impl-side）、图层图像合成则交给合成线程负责处理。这种多线程负责页面内容的渲染框架，在Chrome中称为线程化渲染框架（Threaded Compositor Architecture）。 如上图所示，在Chrome的线程化渲染框架中，当内核线程完成第一帧的布局和记录绘制操作时，立即通知合成线程对第一帧进行渲染，然后内核线程就开始准备第2帧的布局和记录绘制操作。由此可以看出，内核线程在进行N+1帧的布局和记录绘制操作的同时，合成线程也在努力进行第N帧的渲染并交给屏幕展示。这里利用了CPU多核的特性进行并发处理，提高了页面的渲染效率。用户看到的页面内容是上一帧的内容快照，新的一帧还在处理中。 要优化第2个问题，对浏览器来说是非常困难的。只要输入事件要在内核线程执行逻辑，那么遇到内核线程在忙，必然无法立即得到响应。如用户的大部分输入事件都跟页面元素有关系，一旦页面元素注册了对应事件的监听器，监听器的逻辑代码（javascript）必须在内核线程中执行，这种输入事件经常无法立即得到响应。 有一些输入事件是可以不经过内核线程就能被快速处理的。在Chrome中，这类可以不经过内核线程就能快速处理的输入事件为手势输入事件（滑动、捏合），手势输入事件是由用户连续的普通输入事件组合产生，如连续的mousewheel/touchmove事件可能会生成GestureScrollBegin/GestrueScrollUpdate等手势事件。手势输入事件可以直接在已经渲染好的内容快照上操作，如滑动手势事件，直接对页面已经渲染好的内容快照进行滑动展示即可。由于线程化渲染框架的支持，手势输入事件可以不经过内核线程，直接有合成线程在内容快照上直接处理，所以即使此时内核线程在忙碌，用户的手势输入事件也可以马上得到响应。小demo可以验证Chrome的这个特性：如在一个有滚动条的页面内通过javascript执行一段死循环的代码（while-true），尝试上下滑动页面，你会发现此时页面仍能流畅地滑动。注：感觉这段有问题。亲测在chrome中js加入死循环，页面卡死，页面并不会正常滚动。另外从MDN查询手势事件（GestureEvent），chrome并不支持手势事件。 在事件处理函数中加入占用内核线程的代码，在没有passive选项的情况下，页面滚动会有卡顿，而在passive为true的时候，页面滚动并不会受事件处理函数复杂度的影响。如下图所示，passive为true的时候，处理器滚动与事件处理函数不是串行的。","categories":[],"tags":[]},{"title":"addEventListener","slug":"addEventListener","date":"2018-02-07T06:29:54.000Z","updated":"2018-10-24T06:02:47.806Z","comments":true,"path":"2018/02/07/addEventListener/","link":"","permalink":"http://yoursite.com/2018/02/07/addEventListener/","excerpt":"","text":"参考 https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener addEventListener是W3C DOM规范中提供的注册事件监听器的方法。 使用方法12345target.addEventListener(type, listener, options);target.addEventListener(type, listener ,&#123;capture: Boolean, bubbling: Boolean, once: Boolean&#125;);target.addEventListener(type, listener, useCapture); type和listener没啥特别的，这个方法我之前用的最多的是第三种形式，查看MDN才发现第三个参数还可以是对象。来看一下这个对象。 capture: Boolean，表示 listener 会在该类型的事件捕获阶段传播到该 EventTarget 时触发。 once: Boolean，表示 listener 在添加之后最多只调用一次。如果是 true， listener 会在其被调用之后自动移除。 passive: Boolean，表示 listener 永远不会调用 preventDefault()。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。 capture与useCapture的效果一样。使用once在调用事件处理函数之后会自动移除该事件监听，即只触发一次，效果与jQuery的$(dom).one(…)一致。passive则明确表示不会调用preventDefault()，如果依然调用，则被忽视。可以使用该参数改善滚屏性能。12var elem = document.getElementById('elem'); elem.addEventListener('touchmove', function listener() &#123; /* do something */ &#125;, &#123; passive: true &#125;); 检测passive可以使用如下代码1234567891011var passiveSupported = false;try &#123; var options = Object.defineProperty(&#123;&#125;, \"passive\", &#123; get: function() &#123; passiveSupported = true; &#125; &#125;); window.addEventListener(\"test\", null, options);&#125; catch(err) &#123;&#125; 另外，对于相同的事件处理函数,addEventListener只会绑定一次123456789ele.addEventListener('click',handler,false);ele.addEventListener('click',handler,false);//只会绑一次ele.addEventListener('click',function()&#123; ...&#125;,false);ele.addEventListener('click',function()&#123; ...&#125;,false);//两个匿名函数即使内容一样，也是两个不同的事件处理函数","categories":[],"tags":[]},{"title":"css shapes（译）","slug":"css-shapes","date":"2018-01-24T03:14:53.000Z","updated":"2018-10-24T06:02:47.816Z","comments":true,"path":"2018/01/24/css-shapes/","link":"","permalink":"http://yoursite.com/2018/01/24/css-shapes/","excerpt":"","text":"由 http://alistapart.com/article/css-shapes-101 翻译 矩形中套矩形：网页通常都是这个构成的。我们通过CSS创造几何形状来打破限制，但那些形状从未影响到被改变形状元素的内部。 1新的CSS Shapes规范改变了这个。在2012年年中由Adobe引入，它的目的是为设计者提供一种新方式来改变在任意复杂形状内部及周围的内容流动。之前不能做到。 Notice how the text wraps around the circular shape of a bowl in this example. Using CSS Shapes, we can create similar designs for the web. Creating a CSS Shape你可以使用Shapes的一个属性将shape应用到元素上。你将shape function作为值传给shape 属性。 形状可以用以下函数中的一个来创建： circle() ellipse() inset() polygon() 接受以上值的形状属性有： shape-outside:在形状外包裹内容 shape-inside:在形状内包裹内容规范暂时不可使用 你可以结合shape-margin使用shape-outside，从而在shape外面增加外边距。对一个元素声明形状很简单：123.element &#123; shape-outside: circle(); /* content will flow around the circle defined on the element */&#125; 或者123.element &#123; shape-outside: url(path/to/image-with-shape.png);&#125; 然而还需要两个条件： 元素必须是浮动的。 元素必须有内在维度（宽高）。所以例子如下：123456.element &#123; float: left; height: 10em; width: 15em; shape-outside: circle();&#125; A Shape’s reference boxCSS Shape 是在参考盒中定义和创建的，用于在元素上绘制形状。除了元素的高度和宽度，元素的盒模型–margin box,content box,padding box及border box也用于作为指定元素形状边界的参考。 默认，margin box用于作为参考，所以如果一个元素在底部有外边距，你在元素上定义的形状将触及margin 区域的边界，而不是border区域。如果你想要用其它的box值，你可以结合shape function指定shape属性：1shape-outside: circle(250px at 50% 50%) padding-box; Defining Shapes using shape functionsSee the Pen KZjKEq by JOHNNY (@JOHNNYGUAN) on CodePen. Defining a shape using an image使用图像作为形状，这个图像需要有alpha通道，从而浏览器可以提取形状。形状是由alpha值大于某一阈值的像素构成的。阈值默认是0.0（完全透明），你也可以通过shape-image-shreshold属性进行更改。 使用url()值指定shape-outside属性，我们可以将内容围绕在该形状周围。 Lorem ipsum dolor sit amet, consectetur adipisicing elit. Harum itaque nam blanditiis eveniet enim eligendi quae adipisci?Assumenda blanditiis voluptas tempore porro quibusdam beatae deleniti quod asperiores sapiente dolorem error! Quo nam quasi soluta reprehenderit laudantium optio ipsam ducimus consequatur enim fuga quibusdam mollitia nesciunt modi.","categories":[],"tags":[]},{"title":"css motion paths（译）","slug":"css-motion-paths","date":"2018-01-24T01:28:10.000Z","updated":"2018-10-24T06:02:47.815Z","comments":true,"path":"2018/01/24/css-motion-paths/","link":"","permalink":"http://yoursite.com/2018/01/24/css-motion-paths/","excerpt":"","text":"由https://codepen.io/danwilson/post/css-motion-paths 翻译当我开始深入探索WAAPI，最有趣的是即将支持Motion Paths(运动路径)–沿特定路径进行动画。在这儿的好处是不言而喻的，在没有它的时候，你要沿一条直线进行过渡，需要写一些keyframe，或者需要借助JS库来帮你抽取逻辑。虽然后者使事情变得简单，简单地在已有的CSS(或者WAAPI)动画中加入路径，仍然是很nice的。 Chrome最近声明他们对于CSS Motion Path module的原生支持 我们怎样做到？在CSS和js中有三个新的motion属性，我们可以将其与transitions，CSS keyframe动画或者WAAPI结合。 MOTION-PATH首先，motion-path定义运动的路径。你可以像在SVG1.1中定义路径一样来定义一条motion-path。1motion-path: path(&quot;M200 200 S 200.5 200.1 348.7 184.4z&quot;); 也可以接受fill-rule作为path中可选的第一个参数。你也可以使用诸如circle，polygon，ellipse和inset的基本形状。如果你使用过CSS Shapes，你会对它很熟悉。最后你也可以通过url()引用形状。 See the Pen CSS Motion Path Spiral by Dan Wilson (@danwilson) on CodePen. MOTION-OFFSET我们使用motion-offset指定物体出现的位置。它可以是一个double length value或者一个百分比。所以当我们沿路径从起始点运动到终点，我们创建一个从0到100%的动画。使用CSS keyframe:12345678@keyframes path-animation &#123; 0% &#123; motion-offset: 0; &#125; 100% &#123; motion-offset: &apos;100%&apos;; &#125;&#125; 使用WAAPI:1234m.animate([ &#123; motionOffset: 0 &#125;, &#123; motionOffset: &apos;100%&apos; &#125;], 1000); MOTION-ROTATION物体面对的方向是由motion-rotation属性处理的。目前有4个主要的方式来处理： 值”auto”意味着元素会随路径旋转。 值”reverse”指元素会随路径旋转，同时加上180度。 “auto Xdeg”（或者”reverse Xdeg”）会额外旋转一定角度。 “Xdeg”时物体会始终保持这个角度。","categories":[],"tags":[]},{"title":"web-animation-api tutorial4: GroupEffects & SequenceEffects","slug":"web-animation-api-tutorial4-GroupEffects-SequenceEffects","date":"2018-01-23T01:23:34.000Z","updated":"2018-10-24T06:02:47.824Z","comments":true,"path":"2018/01/23/web-animation-api-tutorial4-GroupEffects-SequenceEffects/","link":"","permalink":"http://yoursite.com/2018/01/23/web-animation-api-tutorial4-GroupEffects-SequenceEffects/","excerpt":"","text":"由http://danielcwilson.com/blog/2015/09/animations-part-4/ 翻译 我们继续讨论Web Animations API下的 multiple animations，实现群组和队列效果。 KeyframeEffects一个KeyframeEffect接收三个参数：需要做动画的元素，keyframe数组以及时间选项。这个新的对象本质上是一个单独动画的蓝图，但我们讨论群组及队列动画的方式时，我们会接触它。它不会启动一个动画，它只是定义一个动画。1234567891011var elem = document.getElementById('toAnimate');var timings = &#123; duration: 1000, fill: 'both'&#125;var keyframes = [ &#123; opacity: 1 &#125;. &#123; opacity: 0 &#125;];var effect = new KeyframeEffect(elem, keyframes, timings); GroupEffects虽然没有实现并且在Level1 spec也找不到，polyfill提供一种组合动画并将它们一起播放的方式。GroupEffect（即将在Level2 spec出现）将一个或更多的KeyframeEffect组合，用以同时播放。 GroupEffect接收效果参数（代表多个动画的KeyframeEffect数组）。一旦定义，我们可以播放一组动画。 12345678910111213141516var elem = document.getElementById('toAnimate');var elem2 = document.getElementById('toAnimate2');var timings = &#123; duration: 1000&#125;var keyframes = [ &#123; opacity: 1 &#125;. &#123; opacity: 0 &#125;];var kEffects = [ new KeyframeEffect(elem, keyframes, timings), new KeyframeEffect(elem2, keyframes, timings)];var group = new GroupEffect(kEffects);document.timeline.play(group); SequenceEffects与GroupEffect类似，SequenceEffect可以将动画一个接一个播放。你也可以一起使用GroupEffect和SequenceEffect。12var sequence = new SequenceEffect(kEffects);document.timeline.play(sequence); 创建动画的另一种方式火狐支持另一种方式：Animation构造函数。回顾我们之前的方式：1234567891011var elem = document.getElementById('toAnimate');var timings = &#123; duration: 1000, fill: 'both'&#125;var keyframes = [ &#123; opacity: 1 &#125;. &#123; opacity: 0 &#125;];elem.animate(keyframes, timings); 使用同样的变量，下面的代码与之等价12345678910111213141516var kEffect = new KeyframeEffect(elem, keyframes, timings);var player = new Animation(kEffect, elem.ownerDocument.timeline);player.play();//MDN查找代码如下var cats = document.querySelectorAll('.sharedTimelineCat');cats = Array.prototype.slice.call(cats);var sharedTimeline = new DocumentTimeline(&#123; originTime: 500 &#125;);cats.forEach(function(cat) &#123; var catKeyframes = new KeyframeEffect(cat, keyframes, timing); var catAnimation = new Animation(catKeyframes, sharedTimeline); catAnimation.play(); &#125;);","categories":[],"tags":[]},{"title":"web-animations-api-tutorial3-multiple-animations","slug":"web-animations-api-tutorial3-multiple-animations","date":"2018-01-22T15:17:07.000Z","updated":"2018-10-24T06:02:47.825Z","comments":true,"path":"2018/01/22/web-animations-api-tutorial3-multiple-animations/","link":"","permalink":"http://yoursite.com/2018/01/22/web-animations-api-tutorial3-multiple-animations/","excerpt":"","text":"由http://danielcwilson.com/blog/2015/08/animations-part-3/ 翻译 我们讨论多个动画。 每个元素上有多个动画See the Pen multi-animation by JOHNNY (@JOHNNYGUAN) on CodePen. 在这个例子中，每个矩形应用了三个动画（改变transform、opacity和color）。你可以在一个元素上多次调用animate()，这与CSS上使用多个动画是类似的。 使用CSS时：123456#toAnimate &#123; animation: pulse 1s, activate 3000ms, have-fun-with-it 2.5s;&#125;@keyframes pulse &#123; /* ... */ &#125;@keyframes activate &#123; /* ... */ &#125;@keyframes have-fun-with-it &#123; /* ... */ &#125; 使用Web Animations API1234567var animated = document.getElementById('toAnimate');var pulseKeyframes, //defined the keyframes here. activateKeyframes, haveFunKeyframes;var pulse = animated.animate(pulseKeyframes, 1000); //the second parameter as a number is a valid shorthand for durationvar activate = animated.animate(activateKeyframes, 3000);var haveFunWithIt = animated.animate(haveFunKeyframes, 2500); 使用Web Animations API时，创造了三个Animation对象，它们可以被暂停，播放，完成，取消以及通过时间线或播放速率进行操作。 Get the AnimationS,Get Them All当你在调用animate()时没有保存Animation引用时，应该做什么？规范规定在document上有一个getAnimations()方法。在最新版本的规范，这个方法直接在document对象上，火狐48+也是这么实现的。但是Chrome52以及polyfill(v2.2.0)，是根据旧规范实现的，这个方法在timeline对象上。 123//If including the polyfill you can use the followingvar animations = document.getAnimations ? document.getAnimations() : document.timeline.getAnimations();//returns array of all active (not finished and not canceled) animations","categories":[],"tags":[]},{"title":"web-animation-api tutorial2: the animation & timeline controls","slug":"web-animation-api-tutorial2-the-animation-timeline-controls","date":"2018-01-22T10:49:09.000Z","updated":"2018-10-24T06:02:47.823Z","comments":true,"path":"2018/01/22/web-animation-api-tutorial2-the-animation-timeline-controls/","link":"","permalink":"http://yoursite.com/2018/01/22/web-animation-api-tutorial2-the-animation-timeline-controls/","excerpt":"","text":"由http://danielcwilson.com/blog/2015/07/animations-part-2/ 翻译现在我们理解了如何使用Web Animations API，我们再讨论一下状态、控制、回调及时间线。 动画播放状态和控制当调用element.animate()时，会返回一个Animation对象，动画随机开始播放。为了解动画的当前状态，你可以查看只读属性playState，它会返回5个字符串之一。我们也能够通过调用4个方法之一来修改动画的当前状态：1234567var player = element.animate(/* ... */);console.log(player.playState); //\"running\"player.pause(); //\"paused\"player.play(); //\"running\"player.cancel(); //\"idle\"... jump to original stateplayer.finish(); //\"finished\"...jump to end state 除了running,paused,idle和finished的播放状态，还定义了pending状态，这会在播放状态或暂停状态未决时发生。 播放速率通过playbackRate属性来改变播放速率。1234var player = element.animate(/* ... */);console.log(player.playbackRate); //1player.playbackRate = 2; //double speed, can also be decimal to slow it down. 完成回调使用CSS过渡，当过渡结束时会触发事件。类似地，Animation会在动画完成或者调用finish()。注意根据规范，无限次循环的动画集是不能终止的，播放率也不能设为0。也有oncancel句柄，以及Animation完成时使用Promise的选项。 时间线每个Animation暴露出两个读/写时间相关的属性–currentTime和startTime。现在我们关注前者。 currentTime返回动画目前的毫秒数。最大值是delay + (duration iterations)*，所以无限循环不会有最大值。 1234567891011var player = element.animate([ &#123;opacity: 1&#125;, &#123;opacity: 0&#125;], &#123; duration: 1000, delay: 500, iterations: 3&#125;);player.onfinish = function() &#123; console.log(player.currentTime); // 3500&#125;; 播放速率会影响到时间线进展的快慢。如果将播放速率设为10，最大currentTime不变，但是整个时间线会缩短为1/10。 由于currentTime是读/写的，我们可以使用这个跳跃到时间线的某个点。它也可以用来同步两个动画。 另一个选项：reverse()你也可以使用reverse()来反转一个动画，这与play()相似，但是会逆时间线发展。当动画完成时currentTime会是0。","categories":[],"tags":[]},{"title":"web-animation-api tutorial1: creating a basic animation","slug":"web-animation-api-tutorial1-creating-a-basic-animation","date":"2018-01-22T05:49:56.000Z","updated":"2018-10-24T06:02:47.822Z","comments":true,"path":"2018/01/22/web-animation-api-tutorial1-creating-a-basic-animation/","link":"","permalink":"http://yoursite.com/2018/01/22/web-animation-api-tutorial1-creating-a-basic-animation/","excerpt":"","text":"由http://danielcwilson.com/blog/2015/07/animations-part-1/ 翻译 我们已经大致了解了Web Animation API，现在我们深入学习一下真实规范。 WAAPI让你能够比使用CSS动画做更多的控制，我们首先使用这个API做一个基本动画。 构建关键帧动画如果你对CSS过渡/动画熟悉，它看起来会很类似。12345678910111213var player = document.getElementById('toAnimate').animate([ &#123; transform: 'scale(1)', opacity: 1, offset: 0 &#125;, &#123; transform: 'scale(.5)', opacity: .5, offset: .3 &#125;, &#123; transform: 'scale(.667)', opacity: .667, offset: .7875 &#125;, &#123; transform: 'scale(.6)', opacity: .6, offset: 1 &#125; ], &#123; duration: 700, //milliseconds easing: 'ease-in-out', //'linear', a bezier curve, etc. delay: 10, //milliseconds iterations: Infinity, //or a number direction: 'alternate', //'normal', 'reverse', etc. fill: 'forwards' //'backwards', 'both', 'none', 'auto' &#125;); 为了对比起见，有一个同等的CSS关键帧动画。123456789101112131415161718192021@keyframes emphasis &#123; 0% &#123; transform: scale(1); opacity: 1; &#125; 30% &#123; transform: scale(.5); opacity: .5; &#125; 78.75% &#123; transform: scale(.667); opacity: .667; &#125; 100% &#123; transform: scale(.6); opacity: .6; &#125;&#125;#toAnimate &#123; animation: emphasis 700ms ease-in-out 10ms infinite alternate forwards;&#125; 我们将这个动画分解并对各个部分进行解释。1var player = document.getElementById('toAnimate').animate() 这个动画会返回一个Animation对象，我们之后会用它做一些有趣的事，因而要用一个变量将其保存。我们找到想要做动画的元素（这里用document.getElementById获取），调用animate函数。这个函数是新加进规范的，所以你需要测试支持性，或者引入polyfill。 animate函数接收两个参数，一个关键帧效果(KeyframeEffect)数组，一个动画效果时间属性（AnimationEffectTimingProperties）选项。从本质上来看，第一个参数映射为你想要再CSS@keyframes中放置的参数，第二个参数则是你想通过animation-属性指定的CSS规则。这里的关键益处在于我们能够使用变量，或者重复使用预先定义的KeyframeEffect，而在CSS中，我们会受限于我们声明的CSS值。 123456var player = document.getElementById('toAnimate').animate([ &#123; transform: 'scale(1)', opacity: 1 &#125;, &#123; transform: 'scale(.5)', opacity: .5 &#125;, &#123; transform: 'scale(.667)', opacity: .667 &#125;, &#123; transform: 'scale(.6)', opacity: .6 &#125;]); 对于每个KeyframeEffect，我们将CSS中的offset值变为0-1之间的小数offset值。它是可选的，如果你不指定，它们会均匀分布。你也可以指定easing属性，效果与CSS中的animmation-timing-function一致。其它KeyframeEffect中的属性是animate中的属性。每个属性的值应该与你在javascript中使用element.style指定保持一致，所以opacity是数字，transform是字符串。 12345678var player = document.getElementById('toAnimate').animate([], &#123; duration: 700, //milliseconds easing: 'ease-in-out', //'linear', a bezier curve, etc. delay: 10, //milliseconds iterations: Infinity, //or a number direction: 'alternate', //'normal', 'reverse', etc. fill: 'forwards' //'backwards', 'both', 'none', 'auto'&#125;); See the Pen animation by JOHNNY (@JOHNNYGUAN) on CodePen.","categories":[],"tags":[]},{"title":"web animations api（译）","slug":"web-animations-api","date":"2018-01-22T02:36:38.000Z","updated":"2018-10-24T06:02:47.825Z","comments":true,"path":"2018/01/22/web-animations-api/","link":"","permalink":"http://yoursite.com/2018/01/22/web-animations-api/","excerpt":"","text":"由http://danielcwilson.com/blog/2015/07/animations-intro/ 翻译 Let’s talk about the Web Animations API在2014年夏天，谷歌在网上通过Polymer宣告Material design..使用了即将来临的Web Animations API标准的polyfill。 我从未听过这个API，但是我被吸引了，尤其是因为它讨论了MotionPath效果。它还没有完成，但是它提供一种统一CSS、JS和SVG方式来做动画的目的吸引了我。一年后，谷歌和火狐开始实现该标准，polyfill的进程也已经稳定，是时候认真地看待它了。 但是很少有人讨论WAAPI！我希望现在通过写一系列文章，突出它在浏览器中的特色，探索我们为什么想要这个API，搞清楚它们的细微差别。 什么是Web Animation API我们通过弄清它是什么及它想要实现什么来开始这次探索。 动画在过去5年进展很好，有很好的CSS支持以及对javascript的支持。但是在它们提供很多好处的同时，仍然有大量的缺点。 CSS拥有对于平滑过渡的硬件加速，并且是内置于浏览器中的。但是它的规则是在CSS中声明，需要很费劲的使用javascript来动态改变值。 requestAnimationFrame拥有很好的支持，会让浏览器优化何时开始动画，但它仍然可能在有大量其它js运行的时候挂起。它也需要更多的数学来倒计时。 setInterval将很多开发者引入到动画中，但它是不精确的，也会导致不流畅的动画。 jQuery.animate()将其它一些开发者带入动画，但通常会有性能问题。 诸如Velocity和GreenSock(GSAP)提升了js性能，并且在很多场景下测试显示为最佳。但是，它们需要维护并且引入外部库。 通常来说，我们喜欢浏览器尽可能支持并且由浏览器进行优化。浏览器现在有document.querySelector，因为我们看到jQuery提供这种选择DOM元素的方式。所以库中的功能被迁移到浏览器中。理想情况，我们能够将尽可能多的动画控制放在浏览器层面。这些库就可以专注于新特性，然后良性循环。 Web Animation API致力于此。它旨在带来CSS性能方面的能力，加上js的便利和灵活性。 让我们加一些新东西来解决问题在前一份工作，我们收到一份邮件，说他们知道我们在公司事务方面有太多的地方需要查看 – email，办公室监视器，Yammer， Google Chat及intranet/wiki。为解决这个问题，他们加了一个博客。 当我第一次听到Web Animation API的时候，我的想法和我听到我公司要加博客时一样 – 它只会让事情变得更糟。这个博客没有中心化任何事物，它仅仅是额外增加了我们要查看新闻的地方，然后它死掉了。 但是这个感觉是不一样的。规范展示了它的关注点。它不是为了替代已有的行为，而是要统一。语法类似CSS，但是增加了变量、控制和完成回调的选项。","categories":[],"tags":[]},{"title":"atan与atan2(译 wikipedia)","slug":"atan与atan2","date":"2018-01-06T05:25:27.000Z","updated":"2018-10-24T06:02:47.807Z","comments":true,"path":"2018/01/06/atan与atan2/","link":"","permalink":"http://yoursite.com/2018/01/06/atan与atan2/","excerpt":"","text":"概论很多计算机语言都提供了以atan2(y,x)或arctan2(y,x)为名的多值反正切函数。这个函数接受两个参数y和x（不能同时为0，代表X/Y平面中除原点外的任意点(x,y)）。比例y/x为原点到该点的射线与x轴的夹角角&theta;。返回的弧度角封闭在区间(-π,π],并且在y&gt;0时值为正。 Graph of atan2(y,x) over y/x Graph of the tangent function from −π to +π with the corresponding signs of y over x 历史与动机atan2函数首先是在计算机编程语言中引入的，但现在它在科学及工程领域也很常用。它至少可以追溯到FORTRAN编程语言，现在可以在很多现代编程语言中找到。其中有C语言的math.h 标准库，Java Math库，.NET的System.Math，Python的math模块等。 接受一个参数的arctangent函数不能直接区分相对方向。例如，从x轴到向量(1,1)的逆时针角，记为 arctan(1/1)，为π/4弧度或45°。然而，x轴与向量(-1,-1)之间的夹角，为arctan(-1/-1)，但却不是π/4弧度。另外。在求x轴与向量(0,y),y≠0的时候，需要计算arctan(y/0)，但是分母不能为0。 相比之下，arctan2函数可以通过两个变量y和x计算出唯一的反正切值。 定义与计算根据标准反正切函数，arctan2函数可以表示为","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"}]}]}